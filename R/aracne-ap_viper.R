#' Parse inputs (from aracne-ap_viper Nextflow)
#' @param NETWORK ARACNe_AP network file
#' @param EXPRMAT expression matrix in tab-separated format:
#'                header line in format:
#'                geneID sample_1 ... sampleID_n
#'                all other lines in format
#'                geneID_1 value_1 ... value_n etc.
#' @param METADATA metadata to discriminate between cohorts for msViper analysis;
#'                 tab-separated format; header line format:
#'                 sample group
#'                 all other lines:
#'                 sampleID_1 group_0 etc.
#' @param genome_prefix string of a genome in biomart$dataset, suffixed with
#'                      '_gene_ensembl'
#' @param TAG string identifier of the run
#' @return none, saves two RData files to current dir contianing:
#'         ensembl to external gene mapping (en2ext);
#'         combined.eset, regulonaracne required to run msViper
#' @export

parse_aracne <- function(NETWORK, EXPRMAT, METADATA, TAG, genome_prefix = "hsapiens"){

  ##process annotation data
  tx2gene <- RNAseqon::get_tx2gene(genome_prefix)

  ##ARACNe regulon
  print("ARACNe-AP to regulon...")
  regulonaracne <- suppressWarnings(viper::aracne2regulon(afile = NETWORK,
                                                          eset = EXPRMAT))

  ## create eset
  print("Parsing expression matrix...")
  exprd <- readr::read_tsv(EXPRMAT)

  ##check geneID as exernal_gene_name, then convert to ensembl_gene_id
  exprdg <- dplyr::left_join(tx2gene, exprd) %>%
            dplyr::select(external_gene_name, ensembl_gene_id, where(is.numeric))

  exprdh <- highest_exp_wides(wide_object = exprdg,
                             name_col = "external_gene_name",
                             id_col = "ensembl_gene_id",
                             value_cols = 3:dim(exprdg)[2])

  print("Processing metadata...")
  pheno <- readr::read_tsv(METADATA)
  sumatch <- sum(match(colnames(pheno), c("sampleID", "group")))

  if(sumatch != 3 | is.na(sumatch)){
    print("Converting metadata colnames, ensure they are in sample, group order or msViper may fail!")
    colnames(pheno) <- c("sampleID", "group")
  }

  dot_dash <- ifelse(length(strsplit(colnames(exprd)[3], "-")[[1]]),"-", ".")
  phenodf <- pheno %>%
             dplyr::mutate(sampleID = gsub("-", dot_dash, sampleID)) %>%
             dplyr::filter(sampleID %in% colnames(exprd)) %>%
             dplyr::rename(description = group) %>%
             as.data.frame()
  exprds <- exprdh %>%
            dplyr::select(-external_gene_name) %>%
            as.data.frame() %>%
            tibble::column_to_rownames(., var = "ensembl_gene_id")
  phenos <- phenodf[phenodf$sampleID %in% colnames(exprds),]
  print("Creating ExpressionSet...")
  pData <- new("AnnotatedDataFrame",
                data=data.frame(row.names = colnames(exprds),
                                description = factor(phenos$description)))
  combined.eset <- Biobase::ExpressionSet(assayData = as.matrix(exprds),
                                          phenoData = pData)
  print("Saving...")
  save(combined.eset, tx2gene, phenos, exprds, exprdh, regulonaracne, file = paste0(TAG,".parse_inputs.RData"))
}

#' Run msViper
#' @param TAG string identifier of the run
#' @param RDATA RData file generated by parse_input()
#' @return none, saves two RData files to current dir contianing:
#'         ensembl to external gene mapping (en2ext);
#'         combined.eset, regulonaracne required to run msViper
#' @export

run_msviper <- function(TAG, RDATA){

  ##load parse_input RData
  load(RDATA)

  ##generate signature for pairwise description levels
  LEVELS <- levels(factor(phenos$description))
  lapply(seq_along(LEVELS), function(f){

    level1 <- LEVELS[f]
    print(paste0("Working on: ", level1))

    ##require 10+ samples in Group
    if(table(phenos$description %in% level1)[2] > 7){
      pairname <- paste0(gsub(" ","-",level1), "_vs_rest")
      signature <- viper::rowTtest(combined.eset, "description", level1)
      rownamesp <- rownames(signature$p.value)
      signature$p.value <- as.matrix(p.adjust(signature$p.value, method="BH"))
      rownames(signature$p.value) <- rownamesp
      signature <- (qnorm(signature$p.value/2, lower.tail = FALSE) * sign(signature$statistic))[, 1]
      nullmodel <- viper::ttestNull(combined.eset, "description", level1, LEVELS[! LEVELS %in% level1], per = 5000, repos = TRUE, verbose = TRUE)

      ## msViper, leading edge analyses + bootstrapped
      mra <- viper::msviper(ges = signature,
                            regulon = regulonaracne,
                            nullmodel = nullmodel,
                            verbose = FALSE)
      mra <- viper::ledge(mra)
      mra <- viper::shadow(mobj = mra,
                           regulators = 0.01,
                           shadow = 0.01,
                           per = 5000,
                           verbose = FALSE)
      mrac <- viper::msviperCombinatorial(mobj = mra,
                                          regulators = 0.01,
                                          verbose = FALSE)

      ##if statement to deny error from synergy analysis which otherwise exits from the script
      if(length(mrac$regulon) > length(mra$regulon)){
        mra <- viper::msviperSynergy(mobj = mrac, verbose = FALSE)
        ##BH adjust p-values
        mra$es$q.value <- p.adjust(mra$es$p.value, method = "BH")
      }
      if(length(mrac$regulon) == length(mra$regulon)){
        ##BH adjust p-values
        mra$es$q.value <- p.adjust(mra$es$p.value, method = "BH")
      }

      ## outputs
      ##omit NaN as throws error
      mra$signature <- na.omit(mra$signature)
      pdf(paste0(TAG, ".", pairname, ".msViper.syn.results.pdf"))
        plot(mra, pval = mra$es$q.value, cex = .7)
      dev.off()

      mra_tab <- data.frame(NES = mra$es$nes,
                            Size = mra$es$size,
                            p.value = mra$es$p.value,
                            q.value = mra$es$q.value)

      readr::write_tsv(mra_tab, file = paste0(TAG, ".", pairname, ".msViper.results.tsv"))

      retList <- list(mra, mra_tab)
      assignedName <- paste0(pairname)
      assign(assignedName, value = retList)
      saveFile <- paste0(TAG, ".", pairname, ".RData")
      save(list = assignedName, file = saveFile)
    }
  })
}

# ##filter out significant results (p-value)
# #'
# #' @param RDATA object
# #' @param ENS2EXT expression matrix in tab-separated format:
# #'                header line in format:
# #'                geneID sample_1 ... sampleID_n
# #'                all other lines in format
# #'                geneID_1 value_1 ... value_n etc.
# #' @param PVAL metadata to discriminate between cohorts for msViper analysis;
# #'                 tab-separated format; header line format:
# #'                 sample group
# #'                 all other lines:
# #'                 sampleID_1 group_0 etc.
# #' @return none, saves two RData files to current dir contianing:
# #'         ensembl to external gene mapping (en2ext);
# #'         combined.eset, regulonaracne required to run msViper
# #' @export
#
# filter_sig_res <- function(RDATA, ENS2EXT = "ens2ext.RData", PVAL = NULL){
#
#   ##load annotation
#   load(ENS2EXT)
#
#   if(is.null(PVAL)){
#     PVAL <- 0.05
#   }
#
#   for(x in 1:length(RDATA)){
#     print(paste0("Loading: ", RDATA[x]))
#     load(RDATA[x])
#   }
#
#   les <- ls(pattern="vs")
#   got <- get(les)
#   names(got) <- les
#   lapply(seq_along(got), function(ff){
#   f <- got[[ff]]
#   signames <- names(f$es$p.value[f$es$p.value<PVAL])
#   if(length(signames>0)){
#     sigout <- ens2ext %>% dplyr::filter(ensembl_gene_id %in% signames | external_gene_name %in% signames)
#     sigout$size <- f$es$size[names(f$es$size) %in% signames]
#     sigout$pvalue <- f$es$p.value[names(f$es$p.value) %in% signames]
#     sigout$qvalue <- f$es$q.value[names(f$es$q.value) %in% signames]
#     outname <- gsub("RData", "sig.tsv", grep("vs",RDATA,value=T)[ff])
#     write_tsv(sigout, path=outname)
#   }
#   if(length(signames==0)){
#     print(paste0("No significant genes found at p < ", PVAL))
#   }
#   })
# }

#'  The situation arises where a single gene name maps to multiple gene identifiers
#'  e.g. ENSG00000271503, ENSG00000274233 both map to CCL5
#'  this function takes wide format input with at least 3 rows:
#'  1: gene name
#'  2: gene identifier
#'  3: expression value(s) [can be index of columns]
#'  function returns a wide format object with highest expression name+id
#'  also returns full mapping info and mean expression value per name, id pairs
#'
#' @param wide_object a wide tibble or df
#' @param name_col naming column (gene name)
#' @param id_col identification column (gene ID, i.e. ENSID)
#' @param value_col expression value column (can be index)
#' @importFrom magrittr '%>%'
#' @return wide format with higehst exp. when multiple genes same named
#' @export

highest_exp_wides <- function(wide_object, name_col, id_col, value_cols){


  ##create mean_value of all rows, then count name_col
  ##filter out all with name_col single mapping
  mean_map <- wide_object %>% dplyr::select(name_col, id_col, value_cols) %>%
                              dplyr::mutate(mean_value = rowMeans(.[value_cols])) %>%
                              dplyr::group_by_at(dplyr::vars(name_col)) %>%
                              na.omit(mean_value) %>%
                              dplyr::add_count()%>%
                              dplyr::filter(n > 1) %>%
                              dplyr::filter(mean_value == max(mean_value)) %>%
                              dplyr::ungroup() %>%
                              dplyr::distinct_at(dplyr::vars(-id_col), .keep_all = TRUE) %>%
                              dplyr::select(-n, -mean_value)

  ##remove those with multi mapping (in mean_map) from original input
  #mean_map_o <- dplyr::anti_join(wide_object, mean_map, by = name_col) %>%

  ##return the two sets, bound
  #dplyr::bind_rows(mean_map_o, mean_map)
  return(mean_map)
}

#' Make required inputs for ARACNe-AP which is now supported through RNAseqon
#' @param tpm_tb tpms
#' @param metadata metadatas
#' @param meta_group metadatas group
#' @param tag string
#' @importFrom magrittr '%>%'
#' @return wide format with higehst exp. when multiple genes same named
#' @export

make_aracne_inputs <- function(tpm_tb, metadata, meta_group, tag){

  ##from *.de_ready.RData
  exprmat <- tpm_tb %>% dplyr::select(-external_gene_name)

  ##
  # regulators <- de_res %>% dplyr::select(ensembl_gene_id) %>%
  #                          as.data.frame()

  ##
  metaData <- metadata %>% dplyr::select(1, !!meta_group)

  readr::write_tsv(exprmat, file=paste0(tag, ".exprmat.tpm.tsv"))
  # readr::write_tsv(regulators, file=paste0(tag, ".regulators.txt"))
  readr::write_tsv(metaData, file=paste0(tag, ".metaData.txt"))
}
